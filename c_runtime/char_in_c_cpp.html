<fieldset><legend>a.c</legend>
<pre style="white-space: pre-wrap;">
<b>1</b> #include &lt;stdio.h&gt;
<b>2</b> int main(int argc, const char *argv[])
<b>3</b> {
<b>4</b>   printf(&quot;sizeof('a'): %d\n&quot;, sizeof('a'));
<b>5</b>   return 0;
<b>6</b> }
</pre>
</fieldset>

真令人驚訝: 
'a' type is int in c;
sizeof('a'): 4

'a' type is char in c++;
sizeof('a'): 1

這篇提到的問題:&nbsp; <a href="http://www.ptt.cc/bbs/C_and_CPP/M.1357715450.A.04C.html">http://www.ptt.cc/bbs/C_and_CPP/M.1357715450.A.04C.html</a> 在 Expert C Programming 上看到彼此的不同。

永遠有難倒人的題目。小心走火入魔變成王語嫣。

這可能有不少人知道, 但為什麼 c++ 要做如此的改動呢?
原因出在 iostream library:

cout &lt;&lt; 'X'; 會得到 88 (X ascii code), 因為
operator&lt;&lt;(int)
operator&lt;&lt;(char)
這兩個無法符合 overloaded, 這是被當作是相同的參數, 在將 'X' 當作 char 而不是 int 後, cout 才能正常印出 char。

ref: The Design and Evolution of C++ 11.2

