<a href="https://picasaweb.google.com/lh/photo/L3oAt90DzNthPG8lk_GxhNMTjNZETYmyPJy0liipFm0?feat=embedwebsite"><img height="480" src="https://lh4.googleusercontent.com/-uBqq6rbiHgw/UmOkcmQqLuI/AAAAAAAAtO8/LeEPRAPRPuQ/s640/IMGP7914.JPG" width="640" /></a>

自然, 我讀的是簡體中文版本: C++语言的设计与演化, 20131015 委託代買, 20131021 拿到, 60.2/86 rmb, 實際款項 83+60.2*5.1 = 390 nt, 不貴, 在台灣書店買可能需要 86*5 = 430 nt, 重點是我在台灣找不到這本書。

<h2>
目录</h2>
<table><tbody>
<tr> <td><pre>第0章 致读者
第1部分
第1章 C++的史前时代
1.1 Simula和分布式系统
1.2 C与系统程序设计
1.3 一般性的背景

第2章 C with Classes
2.1 C with Classes的诞生
2.2 特征概览
2.3 类
2.4 运行时的效率
2.5 连接模型
2.5.1 纯朴的实现
2.5.2 对象连接模型
2.6 静态类型检查
2.6.1 窄转换
2.6.2 警告的使用
2.7 为什么是C
2.8 语法问题
2.8.1 C声明的语法
2.8.2 结构标志与类型名
2.8.3 语法的重要性
2.9 派生类
2.9.1 没有虚函数时的多态性
2.9.2 没有模板时的容器类
2.9.3 对象的布局模型
2.9.4 回顾
2.10 保护模型
2.11 运行时的保证
2.11.1 构造函数与析构函数
2.11.2 存储分配和构造函数
2.11.3 调用函数和返回函数
2.12 次要特征
2.12.1 赋值的重载
2.12.2 默认实参
2.13 考虑过，但是没有提供的特征
2.14 工作环境

第3章 C++的诞生
3.1 从C with Classes到C++
3.2 目标
3.3 Cfront
3.3.1 生成C
3.3.2 分析C++
3.3.3 连接问题
3.3.4 Cfront发布
3.4 语言特征
3.5 虚函数
3.5.1 对象布局模型
3.5.2 覆盖和虚函数匹配
3.5.3 基成员的遮蔽
3.6 重载
3.6.1 基本重载
3.6.2 成员和友元
3.6.3 运算符函数
3.6.4 效率和重载
3.6.5 变化和新运算符
3.7 引用
3.8 常量
3.9 存储管理
3.10 类型检查
3.11 次要特征
3.11.1 注释
3.11.2 构造函数的记法
3.11.3 限定
3.11.4 全局变量的初始化
3.11.5 声明语句
3.12 与经典C的关系
3.13 语言设计工具
3.14 《C++程序设计语言》（第一版）
3.15 有关“什么是”的论文

第4章 C++语言设计规则
4.1 规则和原理
4.2 一般性规则
4.3 设计支持规则
4.4 语言的技术性规则
4.5 低级程序设计支持规则
4.6 最后的话

第5章 1985-1993年表
5.1 引言
5.2 Release 2.
5.3 带标注的参考手册（ARM）
5.4 ANSI和ISO标准化

第6章 标准化
6.1 什么是标准
6.1.1 实现细节
6.1.2 现实的检查
6.2 委员会如何运作
6.3 净化
6.3.1 查找问题
6.3.2 临时量的生存期
6.4 扩充
6.4.1 评价准则
6.4.2 状况
6.4.3 好扩充的问题
6.4.4 一致性
6.5 扩充建议实例
6.5.1 关键词实参
6.5.2 受限指针
6.5.3 字符集

第7章 关注和使用
7.1 关注和使用的爆炸性增长
7.1.1 C++市场的缺位
7.1.2 会议
7.1.3 杂志和书籍
7.1.4 编译器
7.1.5 工具和环境
7.2 C++的教与学
7.3 用户和应用
7.3.1 早期用户
7.3.2 后来的用户
7.4 商业竞争
7.4.1 传统语言
7.4.2 更新一些的语言
7.4.3 期望和看法

第8章 库
8.1 引言
8.2 C++库设计
8.2.1 库设计的折中
8.2.2 语言特征和库的构造
8.2.3 处理库的多样性
8.3 早期的库
8.3.1 I/O流库
8.3.2 并行支持
8.4 其他库
8.4.1 基础库
8.4.2 持续性和数据库
8.4.3 数值库
8.4.4 专用库
8.5 一个标准库

第9章 展望
9.1 引言
9.2 回顾
9.2.1 C++在其预期领域取得了成功吗？
9.2.2 C++是不是一种统一的语言？
9.2.3 什么是最大失误？
9.3 仅仅是一座桥梁吗？
9.3.1 在一个很长的时期我们还需要这座桥梁
9.3.2 如果C++是答案，那么问题是什么？
9.4 什么能使C++更有效
9.4.1 稳定性和标准
9.4.2 教育和技术
9.4.3 系统方面的问题
9.4.4 在文件和语法之外
9.4.5 总结

</pre>
</td>   <td><pre>第2部分
第10章 存储管理
10.1 引言
10.2 将存储分配和初始化分离
10.3 数组分配
10.4 放置
10.5 存储释放问题
10.6 存储器耗尽
10.7 自动废料收集
10.7.1 可选的废料收集
10.7.2 可选择的废料收集应该是什么样子的？

第11章 重载
11.1 引言
11.2 重载的解析
11.2.1 细粒度解析
11.2.2 歧义控制
11.2.3 空指针
11.2.4 overload关键字
11.3 类型安全的连接
11.3.1 重载和连接
11.3.2 C++连接的一种实现
11.3.3 回顾
11.4 对象的建立和复制
11.4.1 对复制的控制
11.4.2 对分配的控制
11.4.3 对派生的控制
11.4.4 按成员复制
11.5 记法约定
11.5.1 灵巧指针
11.5.2 灵巧引用
11.5.3 增量和减量的重载
11.5.4 重载 -&gt;*
11.5.5 重载逗号运算符
11.6 给C++增加运算符
11.6.1 指数运算符
11.6.2 用户定义运算符
11.6.3 复合运算符
11.7 枚举
11.7.1 基于枚举的重载
11.7.2 布尔类型

第12章 多重继承
12.1 引言
12.2 普通基类
12.3 虚基类
12.4 对象布局模型
12.4.1 虚基布局
12.4.2 虚基类和强制
12.5 方法组合
12.6 有关多重继承的论战
12.7 委托
12.8 重命名
12.9 基类和成员初始化

第13章 类概念的精练
13.1 引言
13.2 抽象类
13.2.1 为处理错误而用的抽象类
13.2.2 抽象类型
13.2.3 语法
13.2.4 虚函数和构造函数
13.3 const成员函数
13.3.1 强制去掉const
13.3.2 const定义的精练
13.3.3 可变性与强制
13.4 静态成员函数
13.5 嵌套的类
13.6 Inherited：：
13.7 放松覆盖规则
13.8 多重方法
13.9 保护成员
13.10 改进代码生成
13.11 指向成员的指针

第14章 强制转换
14.1 主要扩充
14.2 运行时类型信息
14.2.1 问题
14.2.2 dynamic_cast运算符
14.2.3 RTTI的使用和误用
14.2.4 为什么提供一个“危险特征”
14.2.5 typeid()运算符
14.2.6 对象布局模型
14.2.7 一个例子：简单的对象I/O
14.2.8 考虑过的其他选择
14.3 强制的一种新记法
14.3.1 问题
14.3.2 static_cast运算符
14.3.3 reinterpret_cast运算符
14.3.4 const_cast运算符
14.3.5 新风格强制的影响

第15章 模板
15.1 引言
15.2 模板
15.3 类模板
15.4 对模板参数的限制
15.4.1 通过派生加以限制
15.4.2 通过使用加以限制
15.5 避免代码重复
15.6 函数模板
15.6.1 函数模板参数的推断
15.6.2 描述函数模板的参数
15.6.3 函数模板的重载
15.7 语法
15.8 组合技术
15.8.1 表述实现策略
15.8.2 描述顺序关系
15.9 模板类之间的关系
15.9.1 继承关系
15.9.2 转换
15.9.3 成员模板
15.10 模板的实例化
15.10.1 显式的实例化
15.10.2 实例化点
15.10.3 专门化
15.10.4 查找模板定义
15.11 模板的作用
15.11.1 实现与界面的分离
15.11.2 灵活性和效率
15.11.3 对C++其他部分的影响

第16章 异常处理
16.1 引言
16.2 目标和假设
16.3 语法
16.4 结组
16.5 资源管理
16.6 唤醒与终止
16.7 非同步事件
16.8 多层传播
16.9 静态检查
16.10 不变式

第17章 名称空间
17.1 引言
17.2 问题
17.3 解决方案的思想
17.4 一个解决方案：名称空间
17.4.1 有关使用名称空间的观点
17.4.2 使名称空间投入使用
17.4.3 名称空间的别名
17.4.4 利用名称空间管理版本问题
17.4.5 细节
17.5 对于类的影响
17.5.1 派生类
17.5.2 使用基类
17.5.3 清除全局的static
17.6 与C语言的兼容性
第18章 C语言预处理器
索引 
</pre>
</td> </tr>
</tbody></table>

原文版出版自 199405, 簡體中文出版於 2002 年, 我買的是 201209 再版第二刷。

<a href="https://picasaweb.google.com/lh/photo/TXSfz-DVld3H02_VwzB2kx7lyzyq0Rg6WnM09MTnQXU?feat=embedwebsite" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img src="https://lh6.googleusercontent.com/-MRnNlwCY-vU/UmUVxAYYSWI/AAAAAAAAtQU/cgbc1fKDZNw/s400/IMG_6888.JPG" /></a>一開始 Bjarne 談及使用 Simula 來開發他博士論文需要的模擬器與相關的 os 系統。Simula 很好, 也很不好, 最後改用 BCPL 重新把模擬器改寫, 得到了需要的數據, 也順利取得博士學位。這時候他對程式語言有了自己的一套想法, 這些概念, 最後都在 c++ 裡頭實現了。而根據 Bjarne 自己的哲學思想, c++ 就是要支援各種不同的風格, function base, object base, oop, generic programming ... c++11 還來個 functional programming。

p6 有張圖, 秀出一些電腦語言的出生時間點,

p23 提到 Cpre (1981 第1個版本發佈), 這是 c with class 的 preprocessor
p34 說明 this 為什麼是 this 而不是 self (取自 simula), 為什麼是 pointer 而不是 reference (因為這時候還沒有 reference)
c 的 f(void), 竟然是被 Bjarne 所遺棄的語法, c++ f() 相當於 c f(void), 這是和 c 不同的地方, 也就是和 c 不相容, 所以 c++ 真的是另外一種語言。
2.7 (p37) 這應該是很多人的疑問, 為什麼是 C, Bjarne 大約用了兩頁在說明原因, 並提到從 simula, algol68, bcpl 那裡「偷」了什麼來 c++ 中。
2.8.1 介紹了 -> 來代替 *, 我的老天, 還好最後 Bjarne 沒這麼做。int v[10]-> 等同於 int *v[10], int f(char)->[10]->(double)-> 對於習慣 c 宣告的我來說, 這也不怎麼高明. 讓 typedef 來對付複雜宣告就好。

c++ 一開始被取名為 C84 (一點都不威阿), 後來 Rick Mascitti 提出了 c++ 這個名字 (真是厲害), 

g++ 1.13 在 198712 公佈, 這是第1個 g++ 版本
cfront (198408 第1個版本發佈) 1986 移植到 pc/at, cfront 並不是 c++ compiler, p59 有張圖可以了解 cfront 的角色, 簡單說透過 cfront 產生的原始碼還要經過 c compiler, 所以才叫 cfront 阿!

c++ 的設計理念之一, 『你只需要為你用的東西付出代價。』用上 class, 和 c 的 struct 一樣, 不會有任何負擔, 加上 virtual function, 呃 ... 這和 c 就不同了, 得付出一點代價。

p77 介紹了對於 operator[]() 這個 operator 重新定義時會有的問題, 以 string 為例子, 引入了輔助用 class 來分別處理左值、右值, 真是巧妙。

garbage collection 在 2.13, 3.9, 10.7 被談到, 尤其是 10.7 花了不少篇幅在討論 garbage collection 所帶來的空間/時間開銷, 這會讓 c++ 威力大減。只提出了 optional garbage collection 的概念

3.8
對於 const 這個關鍵字表現的意義在 c 和 c++ 有所不同, 不過 const 關鍵字可是由 Bjarne 引進到 c 的, 意外吧! 不過當時使用的是 readonly, writeonly 這兩個關鍵字, 最後是由 ANSI C 改用 const 而成為 C 標準, 這是 Bjarne 第一次的標準化經驗, 不過 c 的 const 無法使用在 const expression。

ex:

const int max = 14;
int a[max+1];

在 c 無法這樣使用。別再說 c++ 改變了 c 的 const 用法, 而是 ANSI C 標準委員會沒有採納 Bjarne 的 const 用法。

3.11.1
// 則是由 BCPL 的注解風格, 因為還蠻好用的, Bjarne 就引進了 c++, C99 也支援這個注解風格。

3.11.4 在探討 initialization of global objects, Bjarne 並不是只考慮完成這功能, 還要考慮效率問題, C++ 的設計原則:
"a C++ feature not only has to be usefuel, it also has to be affordable."
這個 c++ 特性不只要有用, 還要能負擔的起。
而這個解決辦法會帶來效率上的問題, 所以說負擔不起。
這個方法是 Jerry Schwarz 所提供。現在的 c++ 似乎已經解決這問題 (我不確定)。

<fieldset><legend>g.c</legend>
<pre>
<b> 1</b> double fabc()
<b> 2</b> {
<b> 3</b>   return 2.34;
<b> 4</b> }
<b> 5</b>
<b> 6</b> double PI = 22/7;
<b> 7</b> double sq = fabc();
<b> 8</b>
<b> 9</b> int main(int argc, char *argv[])
<b>10</b> {
<b>11</b>   return 0;
<b>12</b> }
</pre>
</fieldset>

看來很平凡的程式, 在 c 中是無法編譯成功的, c++ 則可以, 這便是 initialization of global objects 這問題。

descent@debianlinux:tmp$ gcc g.c
g.c:7:1: error: initializer element is not constant
 double sq = fabc();
 ^
descent@debianlinux:tmp$ g++ g.c
descent@debianlinux:tmp$ 

我之前遇到類似的問題, 現在證實了這個的確是 c++ 程式, 而不是 c 程式。
http://descent-incoming.blogspot.tw/2012/09/c-c-global-variable-initialize.html

簡單說, c++ compiler 產生這個:
_Z41__static_initialization_and_destruction_0ii()
幫你完成
sq = fabc();
動作。

simula, algo68, clu, ada, ml, c++ 受這些語言的影響, 

K&R2 (the c programming language 2nd) 裡頭的範例程式碼, 皆可以用 cfront 來編譯, 為了測試與 c 的相容性。

What Is Object-Oriented Programming?
http://www.stroustrup.com/whatis.pdf
這是 Bjarne 應邀在 ASU (The Association of SIMULA Users) 上做的關於 c++ 報告。

<fieldset><legend>b.cpp</legend>
<pre style="white-space: pre-wrap;">
<b>1</b> typedef char *T;
<b>2</b>
<b>3</b> class Y
<b>4</b> {
<b>5</b>   T f(){T a=0; return a;}
<b>6</b>   typedef int T;
<b>7</b> };
</pre>
</fieldset>

g++ 4.8.1 不會過

p126 提到的例子我看不懂。

<fieldset><legend>b.cpp</legend>
<pre style="white-space: pre-wrap;">
<b> 1</b> #include &lt;iostream&gt;
<b> 2</b> #include &lt;typeinfo&gt;
<b> 3</b> using namespace std;
<b> 4</b>
<b> 5</b> typedef int P();
<b> 6</b> typedef int Q();
<b> 7</b>
<b> 8</b> class X
<b> 9</b> {
<b>10</b>   static P(Q); // equivalent static int Q()
<b>11</b> };
</pre>
</fieldset>

這是 6.3.2 p127 提到的暫時物件生命周期, 我把完整程式碼完成並測試。

<fieldset><legend>t.cpp</legend>
<pre style="white-space: pre-wrap;">
<b> 1</b> #include &lt;string&gt;
<b> 2</b> #include &lt;cstdio&gt;
<b> 3</b> 
<b> 4</b> using namespace std;
<b> 5</b> 
<b> 6</b> class Mystring
<b> 7</b> {
<b> 8</b>   public:
<b> 9</b>     friend Mystring operator+(const Mystring&amp;, const Mystring&amp;);
<b>10</b>     Mystring(const char *s)
<b>11</b>     {
<b>12</b>       sprintf(str_, &quot;%s&quot;, s);
<b>13</b>     }
<b>14</b>     ~Mystring()
<b>15</b>     {
<b>16</b>       printf(&quot;~Mystring: %s\n&quot;, str_);
<b>17</b>       str_[0]='1';
<b>18</b>       str_[1]=0x0;
<b>19</b>     }
<b>20</b>     operator const char*()
<b>21</b>     {
<b>22</b>       return str_;
<b>23</b>     }
<b>24</b>   private:
<b>25</b>     char str_[100];
<b>26</b> };
<b>27</b> 
<b>28</b> Mystring operator+(const Mystring &amp;s1, const Mystring &amp;s2)
<b>29</b> {
<b>30</b>   char str[100];
<b>31</b>   sprintf(str,&quot;%s%s&quot;, s1.str_, s2.str_);
<b>32</b>   return Mystring(str);
<b>33</b> }
<b>34</b> 
<b>35</b> int main(int argc, char *argv[])
<b>36</b> {
<b>37</b>   Mystring s1(&quot;123&quot;), s2(&quot;abc&quot;); 
<b>38</b>   const char *p = s1+s2;
<b>39</b>   printf(&quot;%s\n&quot;, p);
<b>40</b>   return 0;
<b>41</b> }
</pre>
</fieldset>

和書中所提結果一樣, L38 之後, 暫時物件就解構了， L39 的 p 就不能保證其正確性。

