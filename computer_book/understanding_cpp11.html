<a href="https://picasaweb.google.com/lh/photo/n1QaSCYJUfc6M0p94dvJ0GRuHxCJ0SXlVBkxmV4KEes?feat=embedwebsite"><img height="360" src="https://lh4.googleusercontent.com/-PH6G2-de8XU/Ue_7GzS56NI/AAAAAAAApPo/6ZjLnu1Ruag/s640/IMG_6578.JPG" width="640" /></a>

<h2>目录</h2>
<table>
<tr>
<td>
<pre>
《深入理解c++11：c++11新特性解析与应用》 
免责声明 
序 
前言 
第1章　新标准的诞生 1 
1.1　曙光：c++11标准的诞生 1 
1.1.1　c++11/c++0x（以及c11/c1x）—新标准诞生 1 
1.1.2　什么是c++11/c++0x 2 
1.1.3　新c++语言的设计目标 3 
1.2　今时今日的c++ 5 
1.2.1　c++的江湖地位 5 
1.2.2　c++11语言变化的领域 5 
1.3　c++11特性的分类 7 
1.4　c++特性一览 11 
1.4.1　稳定性与兼容性之间的抉择 11 
1.4.2　更倾向于使用库而不是扩展语言来实现特性 12 
1.4.3　更倾向于通用的而不是特殊的手段来实现特性 13 
1.4.4　专家新手一概支持 13 
1.4.5　增强类型的安全性 14 
1.4.6　与硬件紧密合作 14 
.1.4.7　开发能够改变人们思维方式的特性 15 
1.4.8　融入编程现实 16 
1.5　本书的约定 17 
1.5.1　关于一些术语的翻译 17 
1.5.2　关于代码中的注释 17 
1.5.3　关于本书中的代码示例与实验平台 18 
第2章　保证稳定性和兼容性 19 
2.1　保持与c99兼容 19 
2.1.1　预定义宏 19 
2.1.2　__func__预定义标识符 20 
2.1.3　_pragma操作符 22 
2.1.4　变长参数的宏定义以及__va_args__ 22 
2.1.5　宽窄字符串的连接 23 
2.2　long long整型 23 
2.3　扩展的整型 25 
2.4　宏__cplusplus 26 
2.5　静态断言 27 
2.5.1　断言：运行时与预处理时 27 
2.5.2　静态断言与static_assert 28 
2.6　noexcept修饰符与noexcept操作符 32 
2.7　快速初始化成员变量 36 
2.8　非静态成员的sizeof 39 
2.9　扩展的friend语法 40 
2.10　final/override控制 44 
2.11　模板函数的默认模板参数 48 
2.12　外部模板 50 
2.12.1　为什么需要外部模板 50 
2.12.2　显式的实例化与外部模板的声明 52 
2.13　局部和匿名类型作模板实参 54 
2.14　本章小结 55 
第3章　通用为本，专用为末 57 
3.1　继承构造函数 57 
3.2　委派构造函数 62 
3.3　右值引用：移动语义和完美转发 68 
3.3.1　指针成员与拷贝构造 68 
3.3.2　移动语义 69 
3.3.3　左值、右值与右值引用 75 
3.3.4　std::move：强制转化为右值 80 
3.3.5　移动语义的一些其他问题 82 
3.3.6　完美转发 85 
3.4　显式转换操作符 89 
3.5　列表初始化 92 
3.5.1　初始化列表 92 
3.5.2　防止类型收窄 96 
3.6　pod类型 98 
3.7　非受限联合体 106 
3.8　用户自定义字面量 110 
3.9　内联名字空间 113 
3.10　模板的别名 118 
3.11　一般化的sfinea规则 119 
3.12　本章小结 121 
第4章　新手易学，老兵易用 123 
4.1　右尖括号]的改进 123 
4.2　auto类型推导 124 
4.2.1　静态类型、动态类型与类型推导 124 
4.2.2　auto的优势 126 
4.2.3　auto的使用细则 130 
</pre>
</td>
<td>
<pre>
4.3　decltype 134 
4.3.1　typeid与decltype 134 
4.3.2　decltype的应用 136 
4.3.3　decltype推导四规则 140 
4.3.4　cv限制符的继承与冗余的符号 143 
4.4　追踪返回类型 145 
4.4.1　追踪返回类型的引入 145 
4.4.2　使用追踪返回类型的函数 146 
4.5　基于范围的for循环 150 
4.6　本章小结 153 
第5章　提高类型安全 155 
5.1　强类型枚举 155 
5.1.1　枚举：分门别类与数值的名字 155 
5.1.2　有缺陷的枚举类型 156 
5.1.3　强类型枚举以及c++11对原有枚举类型的扩展 160 
5.2　堆内存管理：智能指针与垃圾回收 163 
5.2.1　显式内存管理 163 
5.2.2　c++11的智能指针 164 
5.2.3　垃圾回收的分类 167 
5.2.4　c++与垃圾回收 169 
5.2.5　c++11与最小垃圾回收支持 170 
5.2.6　垃圾回收的兼容性 172 
5.3　本章小结 173 
第6章　提高性能及操作硬件的能力 174 
6.1　常量表达式 174 
6.1.1　运行时常量性与编译时常量性 174 
6.1.2　常量表达式函数 176 
6.1.3　常量表达式值 178 
6.1.4　常量表达式的其他应用 180 
6.2　变长模板 183 
6.2.1　变长函数和变长的模板参数 183 
6.2.2　变长模板：模板参数包和函数参数包 185 
6.2.3　变长模板：进阶 189 
6.3　原子类型与原子操作 196 
6.3.1　并行编程、多线程与c++11 196 
6.3.2　原子操作与c++11原子类型 197 
6.3.3　内存模型，顺序一致性与memory_order 203 
6.4　线程局部存储 214 
6.5　快速退出：quick_exit与at_quick_exit 216 
6.6　本章小结 219 
第7章　为改变思考方式而改变 220 
7.1　指针空值—nullptr 220 
7.1.1　指针空值：从0到null，再到nullptr 220 
7.1.2　nullptr和nullptr_t 223 
7.1.3　一些关于nullptr规则的讨论 225 
7.2　默认函数的控制 227 
7.2.1　类与默认函数 227 
7.2.2　“= default”与“= deleted” 230 
7.3　lambda函数 234 
7.3.1　lambda的一些历史 234 
7.3.2　c++11中的lambda函数 235 
7.3.3　lambda与仿函数 238 
7.3.4　lambda的基础使用 240 
7.3.5　关于lambda的一些问题及有趣的实验 243 
7.3.6　lambda与stl 247 
7.3.7　更多的一些关于lambda的讨论 254 
7.4　本章小结 256 
第8章　融入实际应用 258 
8.1　对齐支持 258 
8.1.1　数据对齐 258 
8.1.2　c++11的alignof和alignas 261 
8.2　通用属性 267 
8.2.1　语言扩展到通用属性 267 
8.2.2　c++11的通用属性 268 
8.2.3　预定义的通用属性 270 
8.3　unicode支持 274 
8.3.1　字符集、编码和unicode 274 
8.3.2　c++11中的unicode支持 276 
8.3.3　关于unicode的库支持 280 
8.4　原生字符串字面量 284 
8.5　本章小结 286 
附录a　c++11对其他标准的不兼容项目 287 
附录b　弃用的特性 294 
附录c　编译器支持 301 
附录d　相关资源 304 
</pre>
</td>
</tr>
<table>

20130712 定於三民網路書店 20130722 拿到, 311nt/69rmb, 我是個非常仰賴書籍 (尤其是中文書籍) 的程式學習者。2011 年 11 月千呼萬喚使出來的 c++11 標準, 到了 2013 年我終於願意正式開始學習。

我不喜歡在網路上看片斷的學習資料, 既不完整, 也不過癮, 看這種長篇資料, 我無法長時間盯著螢幕。看那<b>兩本大部頭</b>書籍我也不願意再看, 只為了 c++11 的部份, 終於讓我等到這本書了。不過話說 c++14 又要開始了是吧！不信你看<a href="https://www.ibm.com/developerworks/community/forums/html/topic?id=5bae7171-9700-4810-adb5-c27bbd5ff9bb">C++14中的lambda简介</a>, 那我等到 c++20 後, 在一次學習好了。跑得快不如跑得巧, 現在的我並不那麼熱衷於 c++, 但它還是我最喜歡的語言 (沒有之一)。我比較常用到 c++ 和 c 一樣的部份, 所以我不急著追上度進。

從書中第一章就可以清楚了解 c++11 新的特性, 也介紹 c++ 標準委員會的相關事宜, 本書作者之一 (有之一) Michael Wong 是 c++ 標準委員會成員, 來描述 c++11 特性很有說服力; 其他作者則是在開發 c++11 的 ibm c++ compiler, 實力不容小覷, 還有什麼人能贏過這些人的專業呢？大概也只有<b>那些人</b>了。看完這章後, 我在網路上看到的片斷終於有了統合, 只要花了一小時就有個概念性的了解, 省去我 google 的時間。

2 ~ 8 章便是在談新的特性, 從喜歡的地方開始看就好, 我喜歡 raw string literal, 這種東西早該要有了。

看簡體中文的書籍有術語轉換的問題, 台灣和中國翻譯術語差異頗大, 此書會提到原文術語名稱, 著實的幫助我們了解原文術語, 我覺得這很重要, 雖然我英文看不懂, 但我把原文術語記起來到不是太大問題。

這是 2013 coscup 聽的 c++ 議程:
<a href="http://fsfoundry.org/codefreak/2013/08/04/cpp-%E8%AA%B0%E8%AA%AA%E5%8F%AA%E8%83%BD%E7%A1%AC%E8%91%97%E4%BE%86-coscup-2013/">http://fsfoundry.org/codefreak/2013/08/04/cpp-%E8%AA%B0%E8%AA%AA%E5%8F%AA%E8%83%BD%E7%A1%AC%E8%91%97%E4%BE%86-coscup-2013/</a>

本書都有描述這些特性, 之前看得傻眼的程式碼, 看過本書後, 就清楚多了。

3.3 右值引用 (rvalue reference) 非常精彩, 我很喜歡這節的說明, 3.3.3 將 lvalue, rvalue 做了完整的說明, 什麼時候 c++ compiler 判斷呼叫 Move constructors。對台灣的讀者來說應該是要稱為「右值參考」, 不過右值引用有引用右值的意思, 很容易知道這個術語的意思。唔 ... 我快要習慣「對象」這詞了。

這個東西值不值得花心力搞懂, 我無法下判斷, 只能說帶來了好處, 卻也更要傷腦筋其中的副作用, effective c++ 大概又要出新版了 (http://scottmeyers.blogspot.co.at/2013/01/effective-c11-content-and-status.html), 這節頗為複雜, 得花點功夫閱讀。

分類的方式除了以功能來區分之外, 還考慮了對象 (不是那個 object 奇怪的翻譯), 例如右值引用 (rvalue reference) 主要是給編寫 class 的程式員使用, unicode 的支援則是和所有程式員有關。

8.3.1 (p 275) 談到 big5, 看到中國台灣, 又被矮化了。

2014 年快到了, 學習 c++ 的你還不買本來看。

ref:
書籍資料:
<a href="https://www.ibm.com/developerworks/community/forums/html/topic?id=c8d59b70-0b04-4405-bd16-c4a6a51ec606">https://www.ibm.com/developerworks/community/forums/html/topic?id=c8d59b70-0b04-4405-bd16-c4a6a51ec606</a>

勘誤
<a href="https://www.ibm.com/developerworks/community/forums/html/topic?id=42a85abe-f566-4c7c-ae06-b1bc994a6fcf">https://www.ibm.com/developerworks/community/forums/html/topic?id=42a85abe-f566-4c7c-ae06-b1bc994a6fcf</a>

程式碼:
<a href="https://www.ibm.com/developerworks/community/forums/html/topic?id=c5cd3cb9-9d27-46b3-b9ef-e67223eaadb5">https://www.ibm.com/developerworks/community/forums/html/topic?id=c5cd3cb9-9d27-46b3-b9ef-e67223eaadb5</a>

各家 c++ compiler 支援 c++11 進度
http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport


